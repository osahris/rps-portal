---
#- import_tasks: local_facts.yaml

- name: ensure restic is installed from distribution repositories
  apt:
        name:
          - restic
          - pwgen
          - apache2-utils
        state: present

- name: create /etc/restic directories
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: '0755'
  loop:
    - /etc/restic
    - /etc/restic/config

- name: create /etc/restic directories (II)
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: '0700'
  loop:
    - /etc/restic/repositories
    - /etc/restic/passwords

- name: Create directory for ansible custom facts
  ansible.builtin.file:
    state: directory
    mode: 0700
    path: /etc/ansible/facts.d

- name: Write out restic per-repos secrets
  ansible.builtin.copy:
    dest: '/etc/restic/repositories/{{ item.repository }}.key'
    content: "{{ item.key }}"
  loop: "{{ restic_backup_directives }}"

- name: Generate per-server credentials
  ansible.builtin.shell:
    creates: "/etc/restic/passwords/{{ restic_backup_url_hostport | b64encode }}.pw"
    cmd: "/usr/bin/pwgen -s 16 | dd bs=1 count=16 > /etc/restic/passwords/{{ restic_backup_url_hostport | b64encode }}.pw"
  # TODO: loop over multiple servers, once possible

- name: Hash per-server credentials
  ansible.builtin.shell:
    # always regenerate the facts file until we have a [TODO] trigger for regenerating the password
    cmd: '( /bin/echo -en "[backupuser_htpasswds]\npw1=" ;
            /usr/bin/cat /etc/restic/passwords/{{ restic_backup_url_hostport | b64encode }}.pw | /usr/bin/htpasswd -niB {{ ansible_hostname|quote}}
          ) > /etc/ansible/facts.d/backupuser_htpasswds.fact &&
          chmod 600 /etc/ansible/facts.d/backupuser_htpasswds.fact'

- name: Re-read facts after adding custom fact
  ansible.builtin.setup:
    filter: ansible_local

- name: Loop over servers to re-generate .htpasswd files there
  loop: "{{ groups['backup_servers'] }}"
  loop_control:
    loop_var: backupserver
  # To combine loop/include_tasks with delegate, we include an intermediate task file
  include_tasks: perserver.yaml

- name: Create the restic per-backup config files
  template:
    src: 'per_backup.env.j2'
    dest: '/etc/restic/config/{{ item.name }}.env'
  loop: "{{ restic_backup_directives }}"
  when: item.content is undefined
  # The Systemd service unit will read these via EnvironmentFile=

- name: Create the restic per-backup config files (for special cases)
  ansible.builtin.copy:
    dest: '/etc/restic/config/{{ item.name }}.env'
    content: "{{ item.content }}"
  loop: "{{ restic_backup_directives }}"
  when: item.content is defined
  # or these, depending on the configuration

- name: 'generate "restic repository file" (URL) client-side'
  ansible.builtin.shell:
    cmd: '( /bin/echo -n {{ restic_backup_url_prefix|quote }}{{ ansible_hostname|quote }}: ;
            /bin/echo -n "$(/usr/bin/cat /etc/restic/passwords/{{ restic_backup_url_hostport | b64encode }}.pw)" ;
            /bin/echo @{{ restic_backup_url_hostport | quote }}/{{ ansible_hostname }}_files
          ) > /etc/restic/passwords/{{ restic_backup_url_hostport | b64encode }}.repos &&
          chmod 0600 /etc/restic/passwords/{{ restic_backup_url_hostport | b64encode }}.repos'
    creates: "/etc/restic/passwords/{{ restic_backup_url_hostport | b64encode }}.repos"

#- name: Check repository initialization and status
#  ansible.builtin.shell:
#    creates: "/etc/restic/repositories/{{ item.repository|quote }}.initialized"
#    cmd: >
#      restic stats --json -r {{ restic_backup_url|quote }}{{ item.repository|quote }} --password-file "/etc/restic/repositories/{{ item.repository|quote }}.key"
#          > /etc/ansible/facts.d/restic-repos-{{ item.repository | quote }}.fact   &&
#      touch '/etc/restic/repositories/{{ item.repository|quote }}.initialized'
#  failed_when: false
#  loop: "{{ restic_backup_directives }}"
#  register: repository_x_stats

- name: create a file with the servers' certs
  template:
    src: 'restic-server-certs.pem.j2'
    dest: '/etc/ssl/certs/restic-server-certs.pem'
    mode: 0644

# XXX: Our restic-rest daemon uses a self-signed certificate as generated by "provider-selfsigned.yml".
#      The Go TLS library complains about this cert with the following error message:
#      "x509: certificate relies on legacy Common Name field, use SANs or temporarily enable Common Name matching with GODEBUG=x509ignoreCN=0".
#      Since this doesn't matter for out usecase, we set this ENV var below (and in the environment file) for the forseeable future.
- name: Create repository where necessary
  ansible.builtin.shell:
    creates: "/etc/restic/repositories/{{ item.repository|quote }}.initialized"
    # TODO use RESTIC_REPOSITORY_FILE to not expose secrets via args
    cmd: >
      GODEBUG=x509ignoreCN=0
      restic init -r "$(cat /etc/restic/passwords/{{ restic_backup_url_hostport | b64encode }}.repos)" --json --password-file "/etc/restic/repositories/{{ item.repository|quote }}.key" --cacert "/etc/ssl/certs/restic-server-certs.pem" &&
      touch '/etc/restic/repositories/{{ item.repository|quote }}.initialized'
  loop: "{{ restic_backup_directives }}"

- name: deploy service unit for restic client
  template:
    src: 'restic-backup-oneshot@.service'
    dest: '/etc/systemd/system/'
    mode: 0644

- name: deploy specialized service unit for database backups
  template:
    src: 'restic-backup-oneshot@database.service.j2'
    dest: '/etc/systemd/system/restic-backup-oneshot@{{ item.name|quote }}.service'
    mode: 0644
  loop: "{{ restic_backup_directives }}"
  when: item.database_dump_command is defined

- name: remove specialized service unit where unnecessary
  ansible.builtin.file:
    path: '/etc/systemd/system/restic-backup-oneshot@{{ item.name|quote }}.service'
    state: absent
  loop: "{{ restic_backup_directives }}"
  when: item.database_dump_command is undefined

- name: deploy timer units for restic client
  template:
    src: 'restic-backup-daily@.timer'
    dest: '/etc/systemd/system/'
    mode: 0644

    #notify: systemd reload

- name: Have Systemd read configs
  ansible.builtin.systemd:
    daemon_reload: yes
